# ButCom Protocol Specification

## Overview

ButCom is a lightweight, half-duplex, single-wire protocol for communication between two MCUs (MCU 1 and MCU 2).  
It uses a UART-like framing with a custom byte-level protocol and CRC-8 error detection.

The line is operated in an open-drain style:
- Devices actively drive the line **LOW**.
- The line is pulled **HIGH** via a resistor (internal or external).

---

## Physical Layer

### Signal Levels

- Logic LOW: actively driven to 0V by the MCU pin (OUTPUT, LOW)
- Logic HIGH: line released (INPUT or INPUT_PULLUP), pulled up to VCC by a resistor

### Recommended Hardware

- Voltage: 3.3 V
- Pull-up resistor: ~4.7 kΩ from DATA to 3.3 V
- Optional series resistor (~100 Ω) for ESD / ringing reduction on longer cables

### Timing

Each **bit** has a configurable duration (`bitUs`) via `setBitTimeUs()` or `setSpeedQuality()`.

The protocol uses:

- 1 start bit (LOW)
- 8 data bits (LSB first)
- 1 stop bit (HIGH)

The receiver detects the falling edge (start bit) and then samples in the middle of each bit period.

---

## Byte Frame (Physical)

One byte is encoded as:

```text
   Idle (HIGH)          Start bit        Data bits (LSB first)       Stop bit
       |                     |                 |                          |
       V                     V                 V                          V
   -----------        ____________      ___     _____________        ----------
               HIGH  |            |    |   |   |             |  HIGH
                     |   LOW      |    |   |   |  (0 or 1)   |
                     |            |    |   |   |             |
                     |            |    |   |   |             |
                     ------------      ---   -----------------
                       one bit           8 data bits        one bit
```

The line must be idle (HIGH) for at least 3 bit times (`idleMinUs`) before a new byte can start.

---

## Message Frame (Logical)

Every ButCom message is sent as a sequence of bytes:

```text
START  LEN  TYPE  MSGID  PAYLOAD...  CRC8
 0xA5  xx    xx    xx     xx..       xx
```

- **START**: fixed value `0xA5`
- **LEN**: number of bytes following (TYPE + MSGID + PAYLOAD + CRC)
- **TYPE**:
  - `0` → HELLO
  - `1` → DATA
  - `2` → ACK
- **MSGID**: message ID (1..255), used for matching ACKs and filtering duplicates
- **PAYLOAD**: 0..`BUTCOM_MAX_PAYLOAD` bytes (default 16)
- **CRC8**: CRC-8-ATM over `[LEN, TYPE, MSGID, PAYLOAD...]`

---

## CRC-8

Polynomial: **0x07** (CRC-8-ATM)  
Initial value: **0x00**

Pseudocode:

```c
uint8_t crc8(uint8_t crc, uint8_t data) {
    crc ^= data;
    for (uint8_t i = 0; i < 8; i++) {
        if (crc & 0x80)
            crc = (crc << 1) ^ 0x07;
        else
            crc <<= 1;
    }
    return crc;
}
```

---

## Message Types

### 1. HELLO (`BUTCOM_MSG_HELLO` = 0)

Sent:

- At startup (when `begin(true)` is used)
- Periodically (every `helloIntervalMs`, default 5000 ms)
- Can be triggered by both MCUs

Payload:

```text
payload[0] = senderDeviceId
```

Use this to detect who is on the other side of the bus and whether the other MCU has restarted.

---

### 2. DATA (`BUTCOM_MSG_DATA` = 1)

Application-level messages. The content of `payload[]` is entirely up to the user.  
Examples:

- `payload[0] = 1` → button pressed
- `payload[0] = 0x10, payload[1] = value` → simple typed messages
- `payload[]` as ASCII text for small strings

By default, duplicate DATA frames (same `msgId`) are **ignored** by the receiver, but still ACKed.

---

### 3. ACK (`BUTCOM_MSG_ACK` = 2)

ACK frames are generated by ButCom itself:

- For every received HELLO or DATA frame, the receiver sends an ACK with the **same MSGID**.
- ACK frames have **no payload** (length=3 → TYPE, MSGID, CRC).

The sender can request an ACK when calling:

```cpp
bus.send(payload, length, true);
```

If an ACK is not received within `_ackTimeoutMs`, ButCom retries up to `_maxRetries` times.

---

## Duplicate Filtering

If the sender retries a DATA frame due to a missing ACK, the receiver may see the same DATA frame multiple times. To avoid your application logic executing duplicates:

- ButCom tracks the last `msgId` seen for DATA frames.
- If a new DATA frame arrives with the same `msgId`, it sends an ACK (so the sender stops retrying), but **does not call the user callback again**.

This allows the user code to treat every DATA callback as “exactly once”, under normal error conditions.

---

## HELLO Resynchronization

Because HELLO frames are sent periodically, the bus can recover from:

- One MCU being reset
- MCU being reprogrammed
- Cable re-plugging (assuming power and pull-up remain)

When a HELLO is received:

- The receiver stores `remoteId`
- `hasRemoteId()` becomes `true`

You can read the remote ID at any time:

```cpp
if (bus.hasRemoteId()) {
    uint8_t other = bus.remoteId();
    // use or log the ID
}
```

---

## Recommended Usage Pattern

1. Instantiate `ButCom` with a unique `deviceId` on each MCU.  
2. Call `setSpeedQuality()` on both sides with the same value.  
3. Register a callback with `setCallback()`.  
4. Call `begin(true)` once in `setup()`.  
5. Call `bus.loop()` as often as possible in `loop()`.  
6. Use `send()` to transmit payload buffers.

---

## Timing Diagrams (ASCII)

### Idle and Start Bit

```text
Line:  HIGH  HIGH  HIGH  HIGH  LOW   LOW   LOW ...
Time:  ----idle----   |start bit|
```

### Full Byte (Start + 8 bits + Stop)

```text
    Bit:       Start   b0   b1   b2   b3   b4   b5   b6   b7   Stop
    Time:      ____    ____ ____ ____ ____ ____ ____ ____ ____ ____
Line:     HIGH     LOW    ?    ?    ?    ?    ?    ?    ?    ?   HIGH
```

Where each “?” is driven LOW or released HIGH depending on each bit.

---

## Limits & Notes

- **One device per bus**: ButCom is intentionally point-to-point.
- Max payload size is `BUTCOM_MAX_PAYLOAD` (default: 16 bytes).
- Both MCUs must use the same speed setting (`setSpeedQuality()` or `setBitTimeUs()`).
- The library is cooperative: `loop()` must be called frequently for good performance.

